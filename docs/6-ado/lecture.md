<img src="..\..\resources\EPAM_LOGO_Primary.png?raw=true" width="330" />

# ADO.NET

[1 Введение](#введение)

[2 Архитектура ADO.NET](#архитектура-adonet)

[2.1 Поставщики данных ADO.NET (подключенный слой)](#поставщики-данных-adonet-подключенный-слой)

[2.2 Наборы данных DataSet (Отключенный слой)](#наборы-данных-dataset-отключенный-слой)

[2.3 Выбор между поставщиками данных и DataSet](#выбор-между-поставщиками-данных-и-dataset)

[3 Работа с подключенным слоем ADO.NET](#работа-с-подключенным-слоем-adonet)

[3.1 Создание строки подключения](#создание-строки-подключения)

[3.2 Подключение к БД](#подключение-к-бд)

[3.3 Выполнение запросов](#выполнение-запросов)

[3.4 Использование параметризированных запросов](#использование-параметризированных-запросов)

[3.5 Использование механизма транзакций](#использование-механизма-транзакций)

[4 Для дополнительного чтения](#для-дополнительного-чтения)

[5 Вопросы](#вопросы)

# Введение

Платформа .NET определяет ряд пространств имен, которые позволяют
непосредственно взаимодействовать с локальными и удаленными базами
данных. Вместе эти пространства имен известны как ADO.NET.

ADO (ActiveX Data Objects) — это библиотека компонентов СОМ, получившая
в последние несколько лет множество воплощений. ADO состоит, прежде
всего, из объектов Connection, Command, Recordset и Field. С помощью ADO
открывается соединение с базой данных, после чего некоторые данные
извлекаются и помещаются в набор записей, состоящих из полей; эти данные
затем претерпевают манипуляции и обновления на сервере, после чего
соединение закрывается. Кроме того, ADO предлагает так называемый
отключенный набор записей (disconnected record set), который
используется, когда соединение с базой нежелательно удерживать открытым
в течение длительного времени.

Однако, ADO.NET — это нечто большее, чем просто надстройка над чистым
ADO. В сущности, ADO.NET предоставляет собой технологию работы с
данными, которая основана на платформе .NET Framework. Эта технология
представляет набор классов, через которые возможно отправлять запросы к
базам данных, устанавливать подключения, получать ответ от базы данных и
производить ряд других операций.

Причем важно отметить, что систем управления баз данных может быть
множество. В своей сущности они могут различаться. MS SQL Server,
например, для создания запросов использует язык T-SQL, а MySQL и Oracle
применяют язык PL-SQL. Разные системы баз данных могут иметь разные типы
данных. Также могут различаться какие-то другие моменты. Однако
функционал ADO.NET построен таким образом, чтобы предоставить
разработчикам унифицированный интерфейс для работы с самыми различными
СУБД.

ADO.NET предоставляет самые прямые/низкоуровневые методы доступа к
данным в .NET Framework. На основе методов, предоставляемых ADO.NET,
работают другие, более высокоуровневые программные библиотеки,
позволяющие использовать концептуальную объектную модель данных вместо
физической модели хранения данных.

# Архитектура ADO.NET

В ADO.NET используется многоуровневая архитектура, которая обращается
вокруг небольшого числа ключевых компонентов, таких как поставщики
данных (.NET Framework Data Providers) и DataSet.

## Поставщики данных ADO.NET (подключенный слой)

**Поставщик данных (data provider)** — это набор классов ADO.NET,
которые позволяют получать доступ к определенной базе данных, выполнять
команды SQL и извлекать данные. По сути, поставщик данных — это мост
между вашим приложением и источником данных.

В первом приближении поставщик данных можно рассматривать как набор
типов, определенных в данном пространстве имен, который предназначен для
взаимодействия с конкретным источником данных. Однако независимо от
используемого поставщика данных, каждый из них определяет набор классов,
обеспечивающих основную функциональность. В таблице ниже приведены
некоторые общие основные объекты, их базовые классы (определенные в
пространстве имен System.Data.Common) и основные интерфейсы
(определенные в пространстве имен System.Data), которые они реализуют:

| **Тип объекта** | **Базовый класс** | **Соответствующие интерфейсы**   | **Назначение**                                                                                                                                                                                                                             |
|-----------------|-------------------|----------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Connection      | DbConnection      | IDbConnection                    | Позволяет подключаться к хранилищу данных и отключаться от него. Кроме того, объекты подключения обеспечивают доступ к соответствующим объектам транзакций                                                                                 |
| Command         | DbCommand         | IDbCommand                       | Представляет SQL-запрос или хранимую процедуру. Кроме того, объекты команд предоставляют доступ к объекту чтения данных конкретного поставщика данных                                                                                      |
| DataReader      | DbDataReader      | IDataReader, IDataRecord         | Предоставляет доступ к данным только для чтения в прямом направлении с помощью курсора на стороне сервера                                                                                                                                  |
| DataAdapter     | DbDataAdapter     | IDataAdapter, IDbDataAdapter     | Пересылает наборы данных из хранилища данных к вызывающему процессу и обратно. Адаптеры данных содержат подключение и набор из четырех внутренних объектов команд для выборки, вставки, изменения и удаления информации в хранилище данных |
| Parameter       | DbParameter       | IDataParameter, IDbDataParameter | Представляет именованный параметр в параметризованном запросе                                                                                                                                                                              |
| Transaction     | DbTransaction     | IDbTransaction                   | Инкапсулирует транзакцию в базе данных                                                                                                                                                                                                     |

Конкретные имена этих основных классов различаются у различных
поставщиков (например, SqlConnection, OracleConnection, OdbcConnection и
MySqlConnection), но все эти объекты порождены от одного и того же
базового класса (в случае объектов подключения это DbConnection),
который реализует идентичные интерфейсы (вроде IDbConnection). Поэтому
если вы научитесь работать с одним поставщиком данных, то легко
справитесь и с остальными.

В ADO.NET термин "объект подключения" на самом деле относится к
конкретному типу, порожденному от DbConnection; объекта подключения
"вообще" нет. То же можно сказать и об "объекте команды", "объекте
адаптера данных" и т. д. По соглашению имена объектов в конкретном
поставщике данных имеют префиксы соответствующей СУБД (например,
SqlConnection, OracleConnection, SqlDataReader и т. д.).

Одной из ключевых идей, лежащих в основе модели поставщиков ADO.NET,
является расширяемость. Другими словами, разработчики могут создавать
собственные поставщики для патентованных источников данных. В
действительности доступно множество подтверждающих это примеров, которые
демонстрируют, как создавать настраиваемые поставщики ADO.NET, служащие
оболочками для нереляционных хранилищ данных, таких как файловая система
или служба каталогов. Некоторые независимые производители также продают
собственные поставщики данных для .NET.

В рамках .NET Framework поставляется небольшой набор из четырех
поставщиков:

**SQL Server — п**редоставляет оптимизированный доступ к базам данных
SQL Server (версии 7.0 и выше).

**OLE DB —** предоставляет доступ к любому источнику данных, который
имеет драйвер OLE DB. Это включает базы данных SQL Server версий,
предшествующих 7.0.

**Oracle —** предоставляет оптимизированный доступ к базам данных Oracle
(версии 8i и выше).

**ODBC—** предоставляет доступ к любому источнику данных, имеющему
драйвер ODBC.

В версии .NET 4 поставщик Oracle объявлен устаревшим. И хотя он
по-прежнему работает, в Microsoft рекомендуют применять вместо него для
доступа к базам данных Oracle поставщик от стороннего производителя,
такой как ODP.NET (Oracle Data Provider для .NET) производства Oracle,
который доступен на веб-сайте <http://www.oracle.com>.

При выборе поставщика сначала пытайтесь найти встроенный поставщик .NET,
который предназначен для имеющегося источника данных. Если таковой не
найден, можно воспользоваться OLE DB при наличии драйвера OLE DB для
источника данных.

Технология OLE DB существует уже много лет как часть ADO, поэтому для
большинства источников данных предусмотрены драйверы OLE DB (включая SQL
Server, Oracle, Access, MySQL и многие другие). В тех редких случаях,
когда найти специализированный поставщик .NET или драйвер OLE DB не
удается, можно обратиться к поставщику ODBC, который работает в
сочетании с драйвером ODBC.

При разработке модулей, отвечающих за взаимодействие с БД, рекомендуется
использовать интерфейсы основных объектов, вместо их конкретных
реализаций. Например, стоит использовать **IDbConnection** вместо
**SqlConnection,** и так далее**.** Таким образом, при изменении
источника данных, например с MSSQL БД на Oracle БД, не потребуется
переписывать код, отвечающий за манипуляцию объектами доступов к данным.

Работа с использованием объектов из данного подраздела (Connection,
Command, DataReader, Parameter, Transaction) называется работой с
**подключенным уровнем**, потому что для работы с источником данных
создаётся **подключение,** и все манипуляции данными **происходят в
рамках существующего подключения**.

## Наборы данных DataSet (Отключенный слой)

В .NET существуют типы, которые позволяют эмулировать реляционные данные
с помощью модели объектов, находящихся в памяти. Кроме простого
моделирования табличных данных, состоящих из строк и столбцов, типы из
System.Data позволяют воспроизводить отношения между таблицами,
ограничения столбцов, первичные ключи, представления и другие примитивы
баз данных. К смоделированным данным можно применять фильтры, отправлять
запросы и сохранять (или загружать) данные в формате XML и двоичном
формате. И все это можно делать, даже не подключаясь к СУБД (откуда и
термин "автономный/отключенный уровень") — достаточно загрузить данные
из локального XML-файла или программным образом создать объект
**DataSet**.

Автономные типы действительно можно использовать без подключения к базе
данных, но все-таки обычно применяются подключения (IDbConnection) и
объекты команд (IDbCommand). Кроме того, используется и особый объект —
адаптер данных (расширяющий абстрактный тип DbDataAdapter), который как
раз поставляет и обновляет данные. Но в отличие от подключенного уровня,
данные, полученные через адаптер данных, не обрабатываются с помощью
объектов чтения данных. Вместо этого объекты адаптеров пересылают данные
между вызывающим процессом и источником данных с помощью объектов
DataSet.

Тип DataSet предствляет собой контейнер для любого количества объектов
DataTable, каждый из которых содержит коллекцию объектов DataRow и
DataColumn. Ниже приведена наглядная схема, отображающая поля и свойства
объекта DataSet:

<img src="lecture_media\media\image2.png" style="width:3.84375in;height:3.83333in" />

Объект адаптера данных конкретного поставщика данных автоматически
обслуживает подключение к базе данных. Для повышения масштабируемости
адаптеры данных держат подключение открытым минимально возможное время.

Как только вызывающий процесс получит объект DataSet, вызывающий уровень
полностью отключается от базы данных и остается с локальной копией
удаленных данных. В нем можно вставлять, удалять или изменять строки
различных объектов DataTable, но физическая база данных не обновляется,
пока вызывающий процесс явно не передаст DataSet адаптеру данных для
обновления. По сути, объекты DataSet имитируют постоянное подключение
клиентов, хотя на самом деле они работают с находящейся в памяти базой
данных.

## Выбор между поставщиками данных и DataSet

Когда вы решаете, должно ли ваше приложение использовать поставщики
данных через DataReader или наборы данных через DataSet, следует
рассмотреть виды функциональностей, которые требует разрабатываемое
приложение. Использовать DataSet следует, если есть необходимость:

-   Кэшировать данные в табличном виде локально в памяти приложения,
    чтобы манипулировать ими.

-   Взаимодействовать с данными динамически, например привязывать их к
    Windows Forms элементам или комбинировать и связывать данные из
    множественных источников.

-   Выполнять долгие операции на данных без открытого соединения с
    источником данных.

Если функциональность DataSet, описанная выше, не требуется, то лучше
использовать поставщики данные в связке с DataReader, чтобы вовращать
данные в однонаправленном режиме.

Несмотря на то, что DataAdapter использует внутри себя DataReader для
заполнения содержимого DataSet, используя DataReader напрямую, возможно
значительно увеличить производительность приложения, потому что будет
экономиться память, которая была бы использована DataSet, а также
возможно избежать лишних операций, которые требуются для создания и
заполнения DataSet.

1.  В рамках данной работы использовать функционал DataSet не следует.
    Более того, в общем случае вместо него рекомендуется использовать
    более современные [ORM](https://ru.wikipedia.org/wiki/ORM), например
    ADO.NET Entity Framework, которые позволяют работать в объектной
    модели.

# Работа с подключенным слоем ADO.NET

## Создание строки подключения

Для того, чтобы начать работу с подключенным слоем ADO.NET, прежде всего
нужно создать [строку
подключения](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/connection-strings)
к источнику данных.

Строка подключения содержит сведения для инициализации, передаваемые в
виде параметра от поставщика данных в источник данных. Поставщик данных
получает строку подключения в качестве значения свойства
DbConnection.ConnectionString. Поставщик анализирует строку подключения
и проверяет правильность синтаксиса и наличие ключевых слов. Затем метод
DbConnection.Open() передает проанализированные параметры соединения в
источник данных. Источник данных выполняет дальнейшую проверку и
устанавливает соединение.

Строка подключения представляет собой разделенный точками с запятой
список пар параметров "ключ-значение":

keyword1=value; keyword2=value;

В общем случае строка подключения выглядит примерно так:

```
class Program
{
	static void Main(string[] args)
	{
		string connectionString = @"Data Source=.\\SQLEXPRESS;Initial Catalog=usersdb;Integrated Security=True";
	}
}
```

Ниже приведен список параметров строк подключения:

-   Application Name: название приложения. Может принимать в качестве
    значения любую строку. Значение по умолчанию: ".Net SqlClient Data
    Provide"

-   AttachDBFileName: хранит полный путь к прикрепляемой базе данных

-   Connect Timeout: временной период в секундах, через который
    ожидается установка подключения. Принимает одно из значений из
    интервала 0–32767. По умолчанию равно 15.

    > В качестве альтернативного названия параметра может использоваться Connection Timeout

-   Data Source: название экземпляра SQL Servera, с которым будет идти
    взаимодействие. Это может быть название локального сервера,
    например, "EUGENEPC/SQLEXPRESS", либо сетевой адрес.

    > В качестве альтернативного названия параметра можно использовать Server, Address, Addr и NetworkAddress

-   Encrypt: устанавливает шифрование SSL при подключении. Может
    принимать значения true, false, yes и no. По умолчанию значение
    false

-   Initial Catalog: хранит имя базы данных

    > В качестве альтернативного названия параметра можно использовать Database

-   Integrated Security: задает режим аутентификации. Может принимать
    значения true, false, yes, no и sspi. По умолчанию значение false

    > В качестве альтернативного названия параметра может использоваться Trusted\_Connection

-   Packet Size: размер сетевого пакета в байтах. Может принимать
    значение, которое кратно 512. По умолчанию равно 8192

-   Persist Security Info: указывает, должна ли конфиденциальная
    информация передаваться обратно при подключении. Может принимать
    значения true, false, yes и no. По умолчанию значение false

-   Workstation ID: указывает на рабочую станцию - имя локального
    компьютера, на котором запущен SQL Server

-   Password: пароль пользователя

-   User ID: логин пользователя.

Все строки подключения имеют один и тот же базовый синтаксис, описанный
выше. Набор распознаваемых ключевых слов зависит от поставщика, но в
течение многих лет он превратился в предыдущие API-интерфейсы, такие как
ODBC. Поставщик данных .NET Framework для SQL Server (SqlClient)
поддерживает много ключевых слов из старых API-интерфейсов, но обычно
является более гибким и принимает синонимы для многих общих ключевых
слов строки подключения.

При вводе ошибок могут возникать ошибки. Например*, Integrated
Security=true* является допустимым, но *IntegratedSecurity=true (без
пробела)* вызывает ошибку.

Пример строки подключения, приведенный выше, показывает, <u>как делать
нельзя</u>:

1.  При декомпиляции такого приложения строка подключения будет доступна
    для чтения. Это создаёт дыру в безопасности, которой могут
    воспользоваться злоумышленники.

2.  При изменении строки подключения к базе данных придётся
    перекомпилировать приложение и передавать новые бинарные файлы.

Строки подключения, созданные вручную во время выполнения из
непроверенных входных данных, уязвимы для [атак путем внедрения
строк](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/connection-string-builders#connection-string-injection-attacks)
и поддают риску безопасность в источнике данных. Для решения этих
проблем в ADO.NET 2,0 появились [строители (билдеры) строк
подключения](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/connection-string-builders)
для каждого поставщика данных .NET Framework. Эти построители строк
подключения предоставляют параметры в виде строго типизированных свойств
и позволяют проверить строку подключения перед отправкой в источник
данных.

Билдеры строк подключения применяются, в первую очередь, когда какие-то
параметры подключения определяются во время исполнения программы.
Например, имя пользователя и его пароль. Если строка подключения
является неизменной на всем времени использования программы, следует
использовать [строки подключения в конфигурационных
файлах.](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/connection-strings-and-configuration-files)

Файлы конфигурации приложения содержат настройки, относящиеся к текущему
приложению. Например, приложения Windows содержат дополнительный файл
app.config. В файлах конфигурации присутствуют общие элементы, хотя имя
и расположение любого файла конфигурации в значительной степени зависят
от того, где размещается приложение.

2.  Если при создании проекта отсутствует файл конфигурации, то можно
    добавить его, выполнив следующие действия:

    1.  В строке меню выберите Проект &gt; Добавить новый элемент.

    > Откроется диалоговое окно Добавление нового элемента.

2.  Разверните пункт Установленные &gt; Элементы Visual C\# , а затем
    > выберите шаблон Файл конфигурации приложения.

3.  В текстовом поле Имя введите имя и нажмите кнопку Добавить.

    > Файл с именем app.config добавится в проект.

Строки подключения могут храниться в виде пар "ключ/значение" в разделе
*connectionStrings* элемента *configuration* файла конфигурации
приложения. Дочерние элементы включают *add*, *clear* и *remove*.

Следующий фрагмент файла конфигурации демонстрирует схему и синтаксис
хранения строки соединения. Атрибут *name* является именем, которое
задано для уникальной идентификации строки подключения, чтобы ее можно
было получить во время выполнения. Атрибут *providerName* является
неизменяемым именем поставщика данных .NET Framework, которое
регистрируется в файле machine.config.

```
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <!--другие свойства-->
  <connectionStrings>
    <add name="NorthWindConnectionString"
         providerName="System.Data.SqlClient"
         connectionString="Data Source=(local);Initial Catalog=NorthWind;Integrated Security=True"/>
  </connectionStrings>
</configuration>
```

В этом фрагменте файла конфигурации указана строка подключения к [БД
NorthWind](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/linq/downloading-sample-databases#get-the-northwind-sample-database-for-sql-server),
развернутой на MS SQL Server.

Пример использования указанной строки подключения и данного файла
конфигурации приведен ниже. Более подробно о работе с конфигурационными
файлами и классом *ConfigurationManager* можно почитать [в официальной
документации.](https://docs.microsoft.com/ru-ru/dotnet/api/system.configuration.configurationmanager?view=netframework-4.8)

## Подключение к БД

Для того, чтобы использовать эту строку подключения, необходимо создать
[объект подключения к источнику
данных](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.common.dbconnection?view=netframework-4.8),
использующий данную строку подключения. Для простоты в данном примере
явно создаём SqlConnection:

```
public static void Main(string[] args)
{
	// Получение именнованной строки подключения из файла конфигурации
	string connectionString = ConfigurationManager
		.ConnectionStrings["NorthWindConnectionString"]
		.ConnectionString;

	using (SqlConnection dbConnection = new SqlConnection(connectionString))
	{
		dbConnection.Open();
		// Работа с базой данных
		dbConnection.Close();
	}
}
```

3.  Важно отметить, что рекомендуется делать обобщенные методы по работе
    с объектами БД. Подробнее можно почитать в [описании
    DbProviderFactories](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/dbproviderfactories).

## Выполнение запросов

Для выполнения запросов (или команд) к источнику данных, необходимо
создать подходящий объект класса-наследника DbCommand, например
SqlCommand. Основные свойства этого объекта — это *Connection -* объект
соединения с БД (созданный ранее), и непосредственно сам текст запроса —
CommandText.

Для того, чтобы создать экземпляр класса-команды, можно явно вызывать
соответствующий конструктор с одной из нескольких перегрузок:

```
var command = new SqlCommand();
command.Connection = dbConnection;
command.CommandText = "SELECT @@VERSION";
```

Этот вариант наиболее очевидный, однако в использовании этого варианта
есть недостаток — он менее надёжный и гибкий, так как команда создаётся
конкретно под одного поставщика данных.

Рекомендуемый вариант выглядит следующим образом:

```
var command = dbConnection.CreateCommand();
command.CommandText = "SELECT @@VERSION";
```

Метод *CreateCommand*, определенный в интерфейсе IDbConnection, создаст
правильный объект команды, исходя из типа созданного соединения. В этом
случае получается абстрагироваться от конкретного типа поставщика
данных, и при этом возможно создавать общие методы взаимодействия с
различными источниками данных.

4.  Практически все объекты взаимодействия с БД являются наследниками
    [IDisposable](https://docs.microsoft.com/ru-ru/dotnet/api/system.idisposable?view=netframework-4.8#remarks).
    Это означает, что важно вовремя высвобождать занятые этими объектами
    ресурсы. Для этого проще всего пользоваться конструкцией
    [using](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/using-statement).
    Таким образом, правильное использование объекта-команды выглядит
    следующим образом:

```
// Инициализируем объект команды
using (var command = dbConnection.CreateCommand())
{
	// заполняем объект команды данными для запроса
	command.CommandText = "SELECT @@VERSION";
	// выполняем запрос
	var result = command.ExecuteScalar();
	// обрабатываем результат
	Console.WriteLine(result);
} // при выходе из данного блока произойдёт высвобождение захваченных ресурсов
```

Существует несколько способов выполнения команд. Интерфейс IDbCommand
определяет три основных метода для выполнения запросов:
[ExecuteNonQuery](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.idbcommand.executenonquery?view=netframework-4.8#System_Data_IDbCommand_ExecuteNonQuery),
[ExecuteReader](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.idbcommand.executereader?view=netframework-4.8#System_Data_IDbCommand_ExecuteReader)
и
[ExecuteScalar](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.idbcommand.executescalar?view=netframework-4.8#System_Data_IDbCommand_ExecuteScalar).
Пример использования последнего запроса приведен выше. В результате его
выполнения в вызывающий код возвращается значение из первого столбца
первой строки. В данном случае – версия MS SQL Server.

Метод *ExecuteNonQuery* хорошо подходит для запросов INSERT, UPDATE,
DELETE. Результатом выполнения этого метода является целочисленное
число, означающее количество затронутых строк:

```
// Инициализируем объект команды
using (var command = dbConnection.CreateCommand())
{
	// заполняем объект команды данными для запроса
	command.CommandText = @"INSERT INTO Region VALUES (5, 'CIS')";
	// выполняем запрос
	int result = command.ExecuteNonQuery();
	// обрабатываем результат
	Console.WriteLine($"Число задействованных запросом строк: {result}");
}
```

Наибольший интерес представляет метод *ExecuteReader.* Этот метод
открывает поток чтения из источника данных. Чтение происходит построчно,
при этом важен порядок столбцов (лучше не использовать *SELECT \** при
работе с ADO.NET). В примере ниже производится чтение столбцов с
различными типами:

```
// Инициализируем объект команды
using (var command = dbConnection.CreateCommand())
{
	// заполняем объект команды данными для запроса
	command.CommandText = @"SELECT OrderID, OrderDate, Freight, ShipCountry
                   FROM Orders";
	// выполняем запрос
	using (var reader = command.ExecuteReader())
	{
		// убеждаемся, что получили какие-то строки
		if (reader.HasRows)
		{
			// обрабатываем результат
			while (reader.Read())
			{
				int orderId = reader.GetInt32(0);
				DateTime orderDate = reader.GetDateTime(1);
				decimal freight = reader.GetDecimal(2);
				string shipCountry = reader.GetString(3);

				Console.WriteLine($"Order: {orderId} \n OrderDate: {orderDate} \n Freight: {freight} \n ShipCountry: {shipCountry}");
			}
		}
		else
		{
			Console.WriteLine("Не получили строки из источника данных!");
		}
	}
}
```

В этом примере при получении значения из объекта чтения явно указываются
позиции, на которых ожидаются те или иные значения, например вызов
*reader.GetInt32(0)* попытается получить значение из первой ячейки
текущей строки и привести его к типу Int32 (равнозначно простому int).
Можно использовать метод
[GetValue](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.sqlclient.sqldatareader.getvalue?view=netframework-4.8),
который вернёт объект типа object по указанному индексу, однако это
менее удобный вариант и может скрывать под собой ошибки.

Данный пример сработает для единственного SELECT в запросе. Для
получения нескольких наборов данных в одной команде, необходимо написать
код, аналогичный коду в [этом
примере](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/retrieving-data-using-a-datareader#retrieving-multiple-result-sets-using-nextresult).
При этом такие конструкции являются нежелательными, так как увеличивают
время жизни открытого соединения (при большом количестве клиентов
соединения на сервере БД могут закончиться) и усложняют логику обработки
получения результатов запросов.

## Использование параметризированных запросов

Для того, чтобы избежать
[SQL-инъекций](https://docs.microsoft.com/ru-ru/sql/relational-databases/security/sql-injection?view=sql-server-ver15),
следует использовать запросы с параметрами как для простых запросов на
выборку, так и для вызова хранимых процедур.

Для примера рассмотрим следующую команду:

```
var dateFrom = Console.ReadLine();
// заполняем объект команды данными для запроса
command.CommandText = $@"SELECT OrderID, OrderDate, Freight, ShipCountry
			FROM Orders
			WHERE OrderDate > '{dateFrom}'";
```

Это полностью валидный код, который будет работать. Например, можно
ввести в консоль значение «1998-05-01». Далее, в результате выполнения
этой команды будет выполнен запрос

```
SELECT OrderID, OrderDate, Freight, ShipCountry
FROM Orders
WHERE OrderDate > '1998-05-01'
```

Однако, недобросовестный пользователь или злоумышленник могут ввести в
консоль другое значение, например «1998-05-01';DROP TABLE Customers». В этом случае БД получит запрос следующего вида:

```
SELECT OrderID, OrderDate, Freight, ShipCountry
FROM Orders
WHERE OrderDate > '1998-05-01';DROP TABLE Customers
```

В результате выполнения этого запроса из БД будет удалена указанная
таблица. В иных случаях, в зависимости от обрабатывающего кода,
злоумышленник может получить данные, которые ему не должны быть
доступны. Эти варианты являются недопустимыми для работы с промышленным
ПО.

Для того, чтобы этого избежать, в объекте *Command* существуют параметры
запроса *Parameters.*

В коде, приведенном ниже, показаны варианты создания и использования
объекта-параметра.

```
var dateFrom = Console.ReadLine();
// заполняем объект команды данными для запроса
command.CommandText = $@"SELECT OrderID, OrderDate, Freight, ShipCountry
			FROM Orders
			WHERE OrderDate > @date";

// 1. явное создание и заполнение объекта-параметра
var parameter = command.CreateParameter();
parameter.ParameterName = "@date";
parameter.Value = dateFrom;
// 2. добавление элемента-параметра с именем и значением
command.Parameters.AddWithValue("@date", dateFrom);
```

В этом случае на стороне источника данных будет создана переменная,
подходящая по типу для переданного значения, а затем она будет
поставлена в переданное выражение. Для более эффективной работы можно
явно задавать тип параметров.

Помимо этого, параметры можно и нужно применять при вызове команд как
хранимых процедур. Для примера была написана простенькая хранимая
процедура:

```
CREATE PROCEDURE TestStoredProcedure
	@inputParam INT,
	@outParam VARBINARY OUT
AS
BEGIN
	SELECT @outParam = Picture
	FROM Categories
	WHERE CategoryID = @inputParam
END
```

А так выглядит вызывающий код ADO.NET, позволяющий передать один входной
параметр и получить значение выходного параметра:

```
// заполняем объект команды данными для запроса
command.CommandType = CommandType.StoredProcedure;
command.CommandText = "TestStoredProcedure";

// 1. создание и заполнение входного параметра
var inputParameter = command.CreateParameter();
inputParameter.ParameterName = "@inputParam";
inputParameter.Value = 1;
inputParameter.Direction = ParameterDirection.Input;
inputParameter.DbType = DbType.Int32;
// 2. создание и заполнение выходного параметра
var outParameter = command.CreateParameter();
outParameter.ParameterName = "@outParam";
outParameter.Direction = ParameterDirection.Output;
outParameter.DbType = DbType.Binary;
outParameter.Size = 8000;

command.Parameters.Add(inputParameter);
command.Parameters.Add(outParameter);

// убеждаемся, что выходной параметр пустой
Console.WriteLine(outParameter.Value ?? "null");
// выполняем запрос
command.ExecuteNonQuery();
// убеждаемся, что выходной параметр не пустой
Console.WriteLine(outParameter.Value);
```

Таким образом, параметры команды позволяют избегать внедрения SQL-кода в
обрабатываемые запросы к источнику данных, а также позволяют эффективно
использовать хранимые процедуры, в частности, управлять направлением
данных (входные/выходные параметры).

## Использование механизма транзакций

ADO.NET позволяет в полной мере использовать механизм транзакций баз
данных. В качестве примера использования этого механизма произведем
удаление данных в одной из таблиц, а затем откатим транзакцию:

```
// Инициализируем объект команды
using (var command = connection.CreateCommand())
{
	// создаём и открываем транзакцию
	var transaction = connection.BeginTransaction();
	// заполняем объект команды данными для запроса
	command.CommandText = "DELETE [Order Details]";
	command.Transaction = transaction;

	// выполняем запрос
	var deletedRowsCount = command.ExecuteNonQuery();

	// обрабатываем результат
	Console.WriteLine($"Было удалено {deletedRowsCount} строк");

	// откатываем транзакцию
	command.Transaction.Rollback();
}
```

Если сделать выборку из таблицы \[Order Details\] после выполнения этого
кода, то можно убедиться, что все данные остались неизменными.

Объекты DbTransaction поддерживают все методы транзакций,
предоставляемые источником данных, а также поддерживают стандартные
уровни изоляции выполнения транзакций. Подробнее о работе с транзакциями
можно почитать в [официальной
документации](https://docs.microsoft.com/ru-ru/dotnet/api/system.data.sqlclient.sqltransaction?view=netframework-4.8).

5.  Механизм транзакций является достаточно сложным и тяжеловесным в
    плане производительности. Помимо этого, он может приводить к
    неочевидным ошибкам и блокировкам таблиц. Использованием транзакций
    без необходимости злоупотреблять не рекомендуется.

# Для дополнительного чтения

1.  [Фабрики источники данных – для написания независимого от поставщика
    кода](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/dbproviderfactories)

2.  [Реализация интерфейса
    IDisposable](https://docs.microsoft.com/ru-ru/dotnet/standard/garbage-collection/implementing-dispose)

3.  [Работа с отключенным слоем
    ADO.NET](https://professorweb.ru/my/ADO_NET/base/level2/2_1.php)

4.  [Обзор ORM ADO.NET Entity
    Framework](https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/ef/overview)

5.  [ORM](https://ru.wikipedia.org/wiki/ORM)

6.  Микро-ORM — [Dapper от разработчиков
    StackOverflow](https://dapper-tutorial.net/)

# Вопросы

1.  Чем отличается подключенный слой ADO.NET от
    отключенного/автономного?

2.  Когда может быть полезно выбрать отключенный режим работы?

3.  Перечислить основные объекты подключенного слоя ADO.NET.

4.  Зачем использовать using при работе с подключением к источнику
    данных?

5.  Назвать три основных метода выполнения команды и описать результаты
    их выполнения.

6.  Что такое SQL-инъекция (внедрение SQL-кода)? Как можно не допустить
    внедрения, используя механизмы ADO.NET?
