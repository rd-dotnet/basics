<img src="..\..\resources\EPAM_LOGO_Primary.png?raw=true" width="330" />

# Коллекции в .NET

[1 Введение](#введение)

[2 Коллекции общего назначения](#коллекции-общего-назначения)

[2.1 Массивы](#массивы)

[2.1.1 Определение и особенности](#определение-и-особенности)

[2.1.2 Представление в памяти](#представление-в-памяти)

[2.1.3 Резюме](#резюме)

[2.1.4 Дополнительно](#дополнительно)

[2.2 Динамические массивы](#динамические-массивы)

[2.2.1 Определение и особенности](#определение-и-особенности-1)

[2.2.2 Представление в памяти](#представление-в-памяти-1)

[2.2.3 Резюме](#резюме-1)

[2.2.4 Дополнительно](#дополнительно-1)

[2.3 Списки](#списки)

[2.3.1 Особенности и определение](#особенности-и-определение)

[2.3.2 Представление в памяти](#представление-в-памяти-2)

[2.3.3 Резюме](#резюме-2)

[2.3.4 Дополнительно](#дополнительно-2)

[3 Обобщённые коллекции (Generic)](#обобщённые-коллекции-generic)

[3.1 List&lt;T&gt;](#listt)

[3.1.1 Особенности и определение](#особенности-и-определение-1)

[3.1.2 Представление в памяти](#представление-в-памяти-3)

[3.1.3 Резюме](#резюме-3)

[3.1.4 Дополнительно](#дополнительно-3)

[3.2 Dictionary&lt;TKey, TValue&gt;](#dictionarytkey-tvalue)

[3.2.1 Особенности и определение](#особенности-и-определение-2)

[3.2.2 Представление в памяти](#представление-в-памяти-4)

[3.2.3 Резюме](#резюме-4)

[3.2.4 Дополнительно](#дополнительно-4)

[3.3 KeyValuePair&lt;TKey, TValue&gt;](#keyvaluepairtkey-tvalue)

[4 Сортировка коллекций](#сортировка-коллекций)

[4.1 Сравнение элементов коллекции](#сравнение-элементов-коллекции)

[5 Поиск элементов в коллекции](#поиск-элементов-в-коллекции)

[5.1 Метод Equals](#метод-equals)

[5.2 Метод GetHashCode](#метод-gethashcode)

[5.3 Интерфейс IEquatable&lt;T&gt;](#интерфейс-iequatablet)

[5.4 Резюме](#резюме-5)

[6 Вопросы](#вопросы)

# Введение

В .NET представлено множество видов коллекций, такие как массивы
(статические, динамические), списки, словари, хэш-таблицы и т.д. Все они
используются для хранения множества значений для дальнейшего их
использования.При работе с коллекциями самое главное правильно выбрать
именно ту, которая лучше всего подходит для задачи. Помочь с этим
поможет понимание того, как они устроены.

# Коллекции общего назначения

## Массивы

### Определение и особенности

Массив – ссылочный тип в .NET. Он описывает базовую коллекцию в .NET,
представляющую множество элементов определённой длины и определённого
типа. Ниже представлен пример объявления и инициализации переменной
**myArray** массивом длиной **5** целочисленных (**int**) элементов, а
также пример обращения к элементам массива.

```
int[] myArray = new int[5];
myArray[0] = 1;
myArray[1] = 2;
myArray[4] = 5;
int first = array[1];
int last = array[4];
```

В .NET существует множество способов инициализации массивов:
<https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays#array-initialization>

Вот несколько особенностей массивов в .NET:

-   Нельзя изменить длину массива, если вы создали массив на 5
    элементов, то добавить 6ой элемент уже не получится.

-   При инициализации, массив заполняется default значением выбранного
    типа: для числовых типов (int, short, long, doublt и пр.) это 0, для
    boolean – false, для ссылочных типов – null значением.

-   Обращение к элементам массива осуществляется по индексу.

-   Индексация массива начинается с нуля, это значит, что объявив массив
    длиной 5 элементов, первый будет находиться по индексу 0, а
    последний – 4.

-   Массив может быть любого типа, в том числе массив массивов:
    int\[\]\[\], в этом случае описывается массив ссылочных типов, т.е.
    каждый элемент такого массива будет лишь ссылкой на другой массив.

-   Массивы многут быть одномерными и многомерными: int\[5\] –
    одномерный, int\[3,8\] двухмерный, int\[4,5,3\] трёхмерный, и т.д.

### Представление в памяти

В памяти массивы представленны в виде цельного куска памяти
определённого размера (рармер определяется типом и количеством
элементов). Этот кусок памяти последовательно хранит в себе указанное
количество элементов указанного типа, доступ к которым осуществляется
путём смещения по индексу.

### Резюме

Невозможность изменить размер массива, гарантирует его предсказуемость.
С такой коллекцией просто, быстро и безопасно работать.Благодаря тому,
что это цельный кусок памяти неизменного размера, доступ к элементам
массива практически мгновенный, т.к. сместить указатель на нужный
элемент в памяти достаточно простая операция. Если вам нужно хранить
известное число элементов одного типа, быстро получать к ним доступ и не
нужно добавлять новые (удалять ненужные) элементы, то массив отлично
подходит для этой задачи.

### Дополнительно

Для работы с массивами (сортировка, поиск, изменение размера и прочее) в
.NET представлен класс
[Array](https://docs.microsoft.com/ru-ru/dotnet/api/system.array?view=netframework-4.8).

## Динамические массивы

### Определение и особенности

Динамический массив это массив, размер (длину) которого можно поменять.
В .NET динамический массив представляет класс
[ArrayList](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.arraylist?view=netcore-2.0).

Это довольно устаревшая реализация динамического массива и сейчас не
рекомендуется к использованию в связи с тем, что есть более универсальая
и совершенная реализация:
[List&lt;&gt;](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1?view=netframework-4.8)
о коротой будет рассказано в теме обобщённых коллекций. Также ArrayList
хранит элементы типа object, а значит может хранить одновременно
элементы любого типа. Это может показаться очень универсальным решением,
но на деле, чтобы обратиться к элементу такого массива, потребуется
осуществить преобразование в нужный тип. Тем не менее, он подходит для
того чтобы рассмотреть его лишь в качестве одной из реализаций
динамического массива в .NET.

Ниже представлен пример создания динамического массива и его
использование:

```
ArrayList myDynamicArray = new ArrayList();
myDynamicArray.Add(1);
myDynamicArray.Add(8);
object first = myDynamicArray[0];
```

Вот несколько особенностей динамического массива в .NET:

-   Динамические массивы это надстройка над обычным массивом, поэтому он
    обладает всеми преимуществами, которыми обладает обычный массив.

-   Динамический массив при необходимости самостоятельно изменяет свой
    размер, но эта операция достаточно ресурсоёмкая.

-   Существует только одномерный вариант динамического массива, но не
    что не запрещает создавать массивы массивов.

### Представление в памяти

В памяти динамический массив ничем не отличается от обычного массива.
Отличие заключается лишь в способе управления этой памятью. При создании
динамического массива можно не указывать его длину, в этом случае он
создастся пустым, но при первом добавлении элемента, выделется
количество памяти на 4 элемента (такова реализация динамического
массива, подробнее можно посмотреть
[здесь](https://referencesource.microsoft.com/#mscorlib/system/collections/arraylist.cs,3e3f6715773d6643).).
Если попытаться добавить элемент в заполненный динамический массив, то в
памяти создастся новый массив в два раза больше существующего, в него
скопируются все элементы существующего массива и дальнейшие операции уже
будут происходить с новым массивом, а старый массив так и продолжит
оставаться в памяти, пока его не уничтожит сборщик мусора. Для
программиста все эти действия будут незаметны, в этом удобство
динамического массива, но на деле, подобные операции очень ресурсоёмки,
т.к. двукратное увеличение памяти не всегда является приемлемым
решением.

### Резюме

Динамический массив очень удобен, программисту нет необходимости
заботиться о количестве элементов, так как в случае нехватки места в
коллекцие, динамический массив самостоятельно выделит необходимое
пространство, скопирует все данные и незаметно для программиста
продолжит работу с новой областью памяти. В тоже время может быть
ресурсоёмким в связи с алгоритмом выделения памяти.

### Дополнительно

Подробнее о работе с ArrayList:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.arraylist?view=netcore-2.0>

## Списки

### Особенности и определение

В .NET двунаправленный список представлен обощённым (Generic) классом
LinkedList&lt;&gt; (подробнее об обобщённых классах будет рассказано
позже). Ниже представлен пример создания такого списка:

`LinkedList<int> myLinkedList = new LinkedList<int>();`

Вот несколько особенностей списка:

-   Элементы связанного списка имеют ссылки на следующий и предыдущий
    элемент списка.

-   Нельзя обращаться к элементам такого списка с помощью индексов.

-   Переключаться по элементам такой коллекции можно только
    последовательно вперёд или назад.

### Представление в памяти

В отличии от массива элементы списка хранятся в памяти в произвольном
месте. Эта особенность позволяет не заботиться об изменении размерности
такой коллекции. Но из-за хранения ссылок на следующий и предыдущий
элементы, списку требуется больше памяти для хранения аналогичной
коллекции по сравнению с массивом.

### Резюме

Список подходит для хранения коллекции заранее неизвестного размера. При
добавлении нового элемента не происходит неожиданных затрат оперативной
памяти. В такую коллекцию мгновенно можно добавить новый элемент в любое
место списка. Но из-за своих особенностей перечислять элементы возможно
только от начала или с конца, а значит обратиться к элементу в середине
списка возможно только при последовательном перечислении всех предыдущих
элементов.

### Дополнительно

Подробнее о работе со списком описано в этой статье:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.linkedlist-1?view=netframework-4.8>

# Обобщённые коллекции (Generic)

Обобщённые коллекции отличаются от обычных коллекций тем, что их можно
использовать с разными типами данных. Так как на практике с коллекциями
требуется выполнять типичные операции (поиск, вставка, добавление,
удаление, сортировка) обобщённые коллекции очень удобны. Достаточно один
раз реализовать алгоритм и его можно переиспользовать с разными типами
данных. В момент выполнения компилятор автоматически сгенерирует
коллекцию с нужным типом.

## List&lt;T&gt;

### Особенности и определение

Класс List&lt;T&gt; описывает динамический массив и обладает всеми
преимуществами обычного динамического массива ArrayList (буква «T» всего
лишь принятое обозначение обобщённого типа). При создании такой
коллекции необходимо указать тип, с которым она будет работать:

```
List<int> myList = new List<int>();
myList.Add(1);
myList.Add(15);
int number = myList[0];
```

Благодаря указанию типа при создании, разработчику нет необходимости
преобразовывать элементы коллекции к конкретному типу, как это
необходимо было делать с ArrayList.

Помимо этого класс `List<T>` предоставляет разработчикам множество
методов, которые выполняют самые часто используемые операции при работе
с коллекциями:
[Add](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.add?view=netframework-4.8),
[Insert](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.insert?view=netframework-4.8),
[Remove](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.remove?view=netframework-4.8),
[Sort](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.sort?view=netframework-4.8),
[Find](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.find?view=netframework-4.8)
и
[прочие](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1?view=netframework-4.8#methods).

### Представление в памяти

Как и ArrayList, класс List&lt;T&gt; представляется в памяти как обычный
массив и отличается только способом управления этой памятью. Подробнее о
реализации можно посмотреть в исходном коде:
<https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs>

### Резюме

Класс List&lt;&gt; это, наверное, самая частоиспользуемая коллекция. Она
удобна в использовании благодаря предоставленным методам и достаточно
универсальна так как это Generic коллекция. Но не стоит забывать, что
из-за внутренней реализации управления памятью, возможны чрезмерное
выделение памяти.

### Дополнительно

Подробнее о работе и примерах использования можно прочитать в этой
статье:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1?view=netframework-4.8>

## Dictionary&lt;TKey, TValue&gt;

### Особенности и определение

Класс Dictionary&lt;TKey, TValue&gt; это обобщённая коллекция, которая
описывает структуру данных словарь. Это такая коллекция, каждый элемент
которой имеет ключ и значение. Внутри эта коллекция представляет собой
хэш-таблицу, где в качестве хэша каждого элемента используется [значение
хэша](https://docs.microsoft.com/ru-ru/dotnet/api/system.object.gethashcode?view=netframework-4.8)
ключа этого элемента. Зная ключ элемента, можно мгновенно получить
значение из коллекции. Ниже описан пример создания такой коллекции:

```
Dictionary<int, string> myDictionary = new Dictionary<int, string>();
myDictionary.Add(1, “Hello”);
myDIctionary.Add(2, “World”);
string world = myDictionary[2];
```

Вот несколько особенностей словаря:

-   Ключь элемента словаря не должен быть равен `null`.

-   В качестве ключа и значения может быть использован любой тип.

-   В качестве хэш значения элемента словаря используется результат
    выполнения функции `GetHashCode` объекта, который используется в
    качестве ключа. В связи с этим нужно быть осторожным при
    использовании в качестве ключа ссылочные типы, так как функция
    `GetHashCode` имеет погрешность.

### Представление в памяти

Словарь представляется в памяти как коллекция ключей ассоциативных со
значениями. Как и динамический массив, словарь автоматически расширяется
при нехватки места. Более подробно можно прочитать
[тут](https://habr.com/ru/post/198104/),
[тут](https://docs.microsoft.com/ru-ru/dotnet/standard/collections/hashtable-and-dictionary-collection-types),
а лучше
[тут](https://blog.markvincze.com/back-to-basics-dictionary-part-1/) и
[тут](https://blog.markvincze.com/back-to-basics-dictionary-part-2-net-implementation/).

### Резюме

Словарь лучше всего подойдёт в случае, когда требуется часто совершать
операции поиска и обращения к элементам коллекции. Благодаря своим
особенностям, словарь достаточно ресурсоёмкий.

Важно! Не стоит использовать словарь как панацею для решения задачи
целостного хранения двух разных кллекций «вместе». Если вы чётко
понимаете, что один конкретный ключ ассоциируется с конкретным
значением, то словарь отлично подходит, но если по задаче требуется
просто хранить две коллекции и обеспечивать их целостность (порядок
элементов) до лучше подумать попробовать использовать `List<T>`, а в
качестве типа использовать собственный тип или, к примеру, класс
`KeyValuePair<TKey, TValue>`, об этом классе будет рассказано ниже.

### Дополнительно

Подробнее о работе со словарём можно прочитать в этой статье:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.8>

## KeyValuePair&lt;TKey, TValue&gt;

Класс KeyValuePair&lt;TKey, TValue&gt; не является коллекцией, но связан
с ними. Этот класс используется в Generic коллекциях (в частности в
List&lt;T&gt;) когда требуется в качестве элемента хранить не одно, а
несоклько элементов. Конечно, можно всегда создать собственный класс и
использовать его в качестве элемента коллекции, но зачастую можно
обойтись существующим.

Вот пример использования KeyValuePair&lt;TKey, TValue&gt; класса:

```
List<KeyValuePair<int, string>> myList = new List<KeyValuePair<int, string>>();
myList.Add(new KeyValuePair<int, string>(1, “Hello”));
myList.Add(new KeyValuePair<int, string>(2, “World”));
KeyValuePair<int, string> item = myList[0];
int key = item.Key;
string value = item.Value;
```

# Сортировка коллекций

Сортировка одна из самых востребованных операций для коллекций. Поэтому
в .NET уже присутствует её реализация. Разработчикам нет необходимости
реализовывать свой алгоритм, так как существующие реализация уже
учитывает различные алгоритмы сортировки с учётом размерности массива.

Чтобы отсортировать массив, можно воспользоваться методом класса Array:

```
int[] myArray = new int[] { 1, 6, 3, 8, 5, 2 };
Array.Sort(myArray);
```

Подробнее о сортировке массива можно почитать в этой статье:
<https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=netframework-4.8>.
Если кратко, то:

-   Когда количество элементов меньше или равно 16 используется алгоритм
    сортировки вставками.

-   В остальных случаях применяется [интроспективная
    сортировка](https://ru.wikipedia.org/wiki/Introsort)

Для сотрировки динамического массива можно восспользоваться его
собственным методом Sort:
```
List<int> myList = new List<int> { 1, 4, 6, 3, 2, 9, 7 };
myList.Sort();
```

В данном случае сортировка будет по возрастанию элементов. Помимо вызова
метода Sort без параметров, у класса List есть несколько перегрузок
этого метода, подробнее о каждом из них можно почитать в этой статье:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.sort?view=netframework-4.8>.
Но вот пример одной из них:

```
myList.Sort((left, right) =>
{
    if (left > right) return 1;
    if (left < right) return -1;
    return 0;
})
```

В примере выше используется перегрузка метода Sort которая принимает в
качестве аргумента делегат (функцию), который описывает как сравнивать
два элемента. Что такое делегат будет рассказано в следующей лекции. В
данном случае, если один элемент меньше другого (находится левее по оси
X) то нужно вернуть значение меньше нуля, если больше другого (правее на
оси X), то больше нуля, иначе ноль.

По сути, всё что необходимо разработчику для сортировки коллекции, это
указать как именно нужно сравнивать элементы этой коллекции.

## Сравнение элементов коллекции

При сортировке элементов, существующие алгоритмы опираются на то как
элементы сравниваются друг с другом. В случае с числовыми типами,
элементы коллекции сравниваются по значению, в случае строковых значений
– по алфавиту, а в случае более сложных типов (или собственных классов)
при сортировке будет выдано исключение
System.ArgumentException: At least one object must implement IComparable,
т.к. нет информации о том как сравнивать объекты друг с другом. Если
необходимо поддерживать стандартную сортировку, необходимо чтобы класс,
который вы выбрали в качестве элемента коллекции реализовывал интерфейс
IComparable и предоставлял метод, который описывает алгоритм сравнения
двух элементов коллекции.

Подробнее об этом интерфейсе можно прочитать в этой статье:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.icomparable?view=netframework-4.8>.
А также его обобщённая реализация:
<https://docs.microsoft.com/ru-ru/dotnet/api/system.icomparable-1?view=netframework-4.8>.

# Поиск элементов в коллекции

Задача поиска элемента в коллекции похожа на задачу сортировки. В обоих
случаях происходит сравнение элементов либо между собой (при сортировки)
либо с с конкретным элементов (при поиске). Отличие состоит в том, что
при сортировке, главная задача определить отношение двух элементов
относительно друг друга, путём реализации метода CompareTo, а при
поиске, необходимо точно определить равны ли два элемента друг другу –
метод Equals.

Чтобы проверить, содержит ли динамический массив нужный нам элемент,
достаточно вызвать метод
[Contains](https://docs.microsoft.com/ru-ru/dotnet/api/system.collections.generic.list-1.contains?view=netframework-4.8).

```
List<int> myList = new List<int> { 1,2,6,4,8,6,9 };
bool hasValue = myList.Contains(1); // будет true
```

Также успешно этот метод работает со всеми числовыми и строковыми
типами, так как значимые типы сравниваются по значения, а строки по
своему контенту. Но другие ссылочные типы или пользовательские классы по
умолчанию сравниваются по ссылке, а значит метод Contains вернёт true
лишь в том случае, если ему передать ссылку на уже содержащийся в
коллекции объект:

```
User user1 = new User(“name1”);
User user2 = new User(“name2”);
User user3 = new User(“name3”);
List<User> users = new List<User> { user1, user2, user3 }
bool hasValue = users.Contains(user1); // будет true
```

Но если попытаться найти объект не через его ссылку, а через другой, но
аналогичный объект, то найти его не получится:

```
User existingUser = new User(“name1”);
bool hasAnotherValue = users.Contains(existingUser); // будет false
```

Несмотря на то, что в нашей коллекции users содержится User с именем
“name1”, метод Contains вернёт false, так как переменная existingUser
ссылается на абсолютно другой объект, который создан в новом месте в
куче и просто похож, на существующий объект user1, но не является им.
Так как класс User может быть абсолютно любым и содержать любые поля и
свойства, нельзя однозначно и оптимально определить по каким параметрам
сравнивать пользовательские типы. В связи с этим, в C\# представлено
несколько способов описать то, как сравнивать пользовательские объекты
между собой.

## Метод Equals

Метод Equals это один из методов класса Object, а так как от Object
наследуются все классы в .NET, это гарантирует, что у всех классов, в
том числе и пользовательских, будет присутствовать этот метод. Если не
переопределить этот метод в своём классе, то будет использоваться
стандартная реализация этого метода: для ссылочных типов будут
сравниваться адреса ссылок, а для значимы – их значения. Подробнее о
базовой реализации метода Equals можно узнать из исходного кода:
[так](https://referencesource.microsoft.com/#mscorlib/system/int32.cs,13ad4f778352f7c4,references)
для целых чисел,
[так](https://referencesource.microsoft.com/#mscorlib/system/string.cs,62d7ef71d323486a,references)
для строк, а
[так](https://referencesource.microsoft.com/#mscorlib/system/object.cs,517682d5f6f4f8b4,references)
для object.

Ниже представлена сигнатура метода Equals:

`public virtual bool Equals(Object obj)`

Ключевое слово virtual говорит о том, что в наследниках класса Object
возможно переопределить поведение этого метода, используя ключевое слово
override, например так:

```
class User
{
    public string Name { get; set; }

    public override bool Equals(object obj)
    {
        if (obj == null)
        {
            return false;
        }

        if (obj is User)
        {
            User anotherUser = (User)obj;
            return this.Name == anotherUser.Name;
        }

        return false;
    }
}
```

В описаном выше примере представлен класс User с единственным свойством
Name. Если мы хотим осуществлять поиск по коллекции объектов класса
User, используя стандартные функции .NET, нам необходимо указать как
именно нужно сравнивать наш тип с другими объектами.

В данном примере у класса User реализован метод Equals, который как раз
описывает алгоритм сравнения текущего экземпляра класса User (ключевое
слово this) и другого объекта obj. Для начала нужно убедиться, что
переданный в качестве аргумента объект obj не null. Затем необходимо
убедиться, что переданный объект obj на самом деле очередной экземпляр
класса User, для этого можно воспользоваться оператором
[is](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/type-testing-and-cast#is-operator),
который вернёт true, если obj является объектом класса User. И если это
так, то необходимо сравнить имена двух объектов: this.Name и obj.Name и
вернуть true если они равны и false в противном случае.

## Метод GetHashCode

Но одного метода Equals недостаточно, чтобы гарантировать правильное
сравнение. Дело в том, что для сложных объектов алгоритм сравнения может
быть достаточно сложным и ресурсоёмким в связи с большим количеством
свойств. Поэтому в .NET представлен метод GetHashCode, который
возвращает hash значение объекта. Ниже представлена сигнатура метода
GetHashCode:

`public virtual int GetHashCode()`

Как видно из сигнатуры, этот метод, во-первых, является виртуальным, а
значит его можно переопределить в своём классе, а во-вторых, возвращает
целое число типа Int32.

Этот метод служит для того, чтобы возвращать некое хэш значение объекта.
Алгоритм определения хэш значения изменялся с развитием .NET. Главное
что остаётся неизменным это несколько строгих правил и советов по
реализации этого метода. Подробнее о них можно прочитать в
[этой](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/)
статье. Вот некоторые правила:

-   Равные объекты должны возвращать одинаковое хэш значение.

-   Хэш значнеие объекта не должно зависит от среды выполнения, времени
    и прочих изменяемых параметров.

-   Метод GetHashCode не должен провоцировать исключение.

А вот несколько рекомендаций:

-   Метод GetHashCode должен работать максимально быстро (никаких
    сложных алгоритмов)

-   Для разных объектов должны возвращаться разные значения.

Обратите внимание на первое правило, из него следует, что одинаковые
объекты, должны возвращать одинаковое хэш значение, но это **не**
значит, что если хэш значение одинаковое, то и объекты одинаковые. Это
связано с тем, что метод GetHashCode возвращает целое число типа Int32.
Тип Int32 включает всего около 4 миллиардов уникальных значений, в то
время как в программе может быть создано более 4 миллиардов объектов, а
это значит, что метод так или иначе предполагает некую погрешность. В
связи с чем нельзя полагаться на это значение при сравнении объектов.

Зачем тогда он нужен? Дело в том, что этот метод используется при
алгоритме поиска элемента в коллекции в совокупности с методом Equals.
Алгоритм примерно следующий:

-   Проверяем хэш значения двух объектов.

-   Если они разные, то и объекты разные, а значит начинаем сравнивать
    следующий элемент.

-   Если они одинаковые, то вызываем метод Equals и выполняем тем самым
    «глубокое» сравнение.

Таким образом достигается минимальное количество вызовов метода Equals.
Примеры реализации метода GetHashCode можно найти в интернете.

## Интерфейс IEquatable&lt;T&gt;

Интерфейс
[IEquatable&lt;T&gt;](https://docs.microsoft.com/ru-ru/dotnet/api/system.iequatable-1?view=netframework-4.8)
это обобщённый интерфейс которые регламентирует наличие у класса строго
типизированного метода
[Equals](https://docs.microsoft.com/ru-ru/dotnet/api/system.iequatable-1.equals?view=netframework-4.8).
Этот интерфейс полезен, так как базовый метод Equals класса Object в
качестве аргумента принимает объект класса типа Object, что вынуждает
сначала делать приведение объекта к нужному типу, а лишь потом сравнение
его свойств. Используя интерфейс IEquatable&lt;T&gt; можно реализовать
такую перегрузку метода Equals, которая сразу принимает объект нужного
типа. Примерно так может выглядеть реализация интерфейса
IEquatable&lt;T&gt; в нашем примере:

```
class User : IEquatable<User>
{
    public string Name { get; set; }

    public bool Equals(User other)
    {
        if (other == null)
        {
            return false;
        }

        if (this.Name == other.Name)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public override bool Equals(Object obj)
    {
        if (obj == null)
        {
            return false;
        }

        User user = obj as User;

        if (user == null)

        {
            return false;
        }
        else
        {
            return Equals(user);
        }
    }
}
```

Не стоит забывать о базовой реализации метода Equals, чтобы не сломать
те самые места в коде, которые по-прежнему её используют.

## Резюме

Чтобы обеспечить базовую поддержку поиска и сравнения в .NET необходимо
переопределить в вашем классе методы Equals и GetHashCode. Интерфейс
`IEquatable<T>` можно использовать для удобства, он не обязателен.

# Вопросы

1.  Почему в .NET так много коллекций и почему нельзя было реализовать
    одну обобщённую коллекцию, которая бы идеально подходила для любых
    задач?

2.  Какие особенности у коллекции массив? Как он представлен в памяти?
    Для чего он лучше всего подходит?

3.  Какие особенности у динамического массива и чем он отличается от
    обычного массива? Как динамический массив представлен в памяти?

4.  Какие особенности у связного списка и чем он отличается от
    динамического массива? Как связный список представлен в памяти и для
    каких задач лучше всего подходит?

5.  Что такое обобщённая коллекция и чем она отличается от необобщённой?

6.  Какую структуру описывает класс `List<T>`?

7.  Как устроен `Dictionary<TKey, TValue>`?

8.  Как отсортировать массив значимы типов или строк?

9.  Как отсортировать массив пользовательских типов?

10. Как работает поиск элементов в коллекции?
