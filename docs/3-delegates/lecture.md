<img src="..\..\resources\EPAM_LOGO_Primary.png?raw=true" width="330" />

# Делегаты в .NET


## Содержание


[1 Введение](#введение)

[2 Что такое делегат](#что-такое-делегат)

[3 Анонимные функции](#анонимные-функции)

[4 Delegate vs MulticastDelegate vs delegate](#delegate-vs-multicastdelegate-vs-delegate)

[5 Применение делегатов](#применение-делегатов)

[6 Стандартные типы делегатов](#стандартные-типы-делегатов)

[7 Для дополнительного чтения](#для-дополнительного-чтения)

[8 Вопросы](#вопросы)

# Введение

При разработке .NET Framework самых первых версий разработчики учли
потенциальную необходимость передачи методов в качестве параметров в
другие методы. Для реализации этой возможности были разработаны
специальные типы, которые называются делегатами.

# Что такое делегат

Делегат — это тип, который представляет ссылки на методы с определенным
списком параметров и типом возвращаемого значения. При создании
экземпляра делегата этот экземпляр можно связать с любым методом с
совместимой сигнатурой и типом возвращаемого значения. Метод можно
вызвать (активировать) с помощью экземпляра делегата.

Делегаты используются для передачи методов в качестве аргументов к
другим методам. Делегату можно назначить любой метод из любого
доступного класса или структуры, соответствующей типу делегата. Этот
метод должен быть статическим методом или методом экземпляра. Это
позволяет программно изменять вызовы метода, а также включать новый код
в существующие классы.

Благодаря возможности ссылаться на метод как на параметр делегаты
идеально подходят для определения методов обратного вызова. Например,
ссылка на метод, сравнивающий два объекта, может быть передана в
качестве аргумента алгоритму сортировки. Поскольку код сравнения
находится в отдельной процедуре, алгоритм сортировки может быть написан
более общим способом.

Делегаты имеют следующие свойства:

-   Делегаты подобны указателям на функции в C++, но являются полностью
    объектно-ориентированными и, в отличие от указателей C++ на
    функции-члены, инкапсулируют экземпляр объекта вместе с методом.

-   Делегаты допускают передачу методов в качестве параметров.

-   Делегаты можно использовать для определения методов обратного
    вызова.

-   Делегаты можно связывать друг с другом; например, при появлении
    одного события можно вызывать несколько методов.

-   Точное соответствие методов типу делегата не требуется.

Тип делегата задается его именем. В следующем примере объявляется
делегат с именем MyDelegate, который может инкапсулировать метод,
использующий в качестве аргумента значение
[string](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/reference-types)
и возвращающий значение
[void](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/void):

`public delegate void MyDelegate(string customString);`

Существует несколько способов объявления объекта делегата. Один из них —
это передача именованного метода для инициализации делегата.

```
public static void PrintMessage(string message)
{
    Console.WriteLine($"From {nameof(PrintMessage)}: {message}");
}

// Инициализируем делегат
MyDelegate delegateInstance = PrintMessage;
```

Оператор [*nameof*](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof)
возвращает название члена класса, типа или переменной в виде строки-константы.

После того, как был создан экземпляр делегата, можно выполнить вызов
этого делегата как обычного метода. Этот вызов будет передаваться или,
другими словами, *делегироваться* методу (или нескольким методам, см.
[Раздел](#delegate-vs-multicastdelegate-vs-delegate)), которые скрыты
за этим делегатом. Параметры, передаваемые делегату вызывающим кодом,
передаются в метод(-ы), а возвращаемое методом значение (при его
наличии) возвращается делегатом обратно в вызывающий код. Пример:

```
// Инициализируем делегат
MyDelegate delegateInstance = PrintMessage;

// Вызываем делегат
delegateInstance("Hello World!");
```

# Анонимные функции

С развитием языка появлялись новые, более удобные способы для
инициализации делегата. К таким способам относятся анонимные функции.

Анонимная функция — это "встроенный" оператор или выражение, которое
может использоваться, когда тип делегата неизвестен. Ее можно
использовать для инициализации именованного делегата или передать вместо
типа именованного делегата в качестве параметра метода.

Для создания анонимной функции можно использовать лямбда-выражение или
анонимный метод. Рекомендуется использовать лямбда-выражения, так как
это более лаконичный способ написания встроенного кода.

Лямбда-выражения могут записываться в одной из следующих форм:

1.  `(входные параметры) => выражение`, когда требуется выполнить
    только одну строчку кода.

2.  `(входные параметры) => { блок инструкций }`, когда надо выполнить
    несколько действий.

Для создания анонимного метода используется *оператор delegate.* Его
использование рассмотрим на общем примере со всеми видами объявления
объектов делегатов:

```
public static void PrintMessage(string message)
{
    Console.WriteLine($"From {nameof(PrintMessage)}: {message}");
}

public static void DemonstrateDelegateSyntax()
{
    // Изначальный синтаксис требовал
    // инициализацию с именем метода.
    MyDelegate myDelegate1 = new MyDelegate(PrintMessage);

    // Сейчас можно использовать упрощенный синтаксис:
    // MyDelegate testDelA = PrintMessage;
    // C# 2.0: Делегат может быть инициализирован
    // с помощью "анонимного метода":

    MyDelegate myDelegate2 = delegate (string s)
    {
        Console.WriteLine("From anonymous method: " + s);
    };

    // C# 3.0. Делегат может быть инициализирован
    // с помощью лямбда-выражения.
    MyDelegate myDelegate3 = (x) =>
    {
        Console.WriteLine("From lambda: " + x);
    };

    myDelegate1("One");

    myDelegate2("Two");

    myDelegate3("Three");
}
```

# Delegate vs MulticastDelegate vs delegate

Использование *<u>ключевого слова</u> delegate* для создания собственных
типов делегатов подразумевает, что при компиляции будет неявно создан
новый класс, наследуемый от *<u>класса</u> MulticastDelegate,* который,
в свою очередь, наследуется от *<u>класса</u> Delegate.* Гененируемые
классы являются запечатанными (*sealed*), поэтому их невозможно
использовать в дальнейшем при построении иерархии классов. Наследование
напрямую от базовых классов *MulticastDelegate* и *Delegate* также
запрещено, несмотря на то, что классы объявлены как абстрактные
(*abstract*).

Таким образом, все типы делегатов в .NET являются `MulticastDelegate`.
Это означает, что делегат может содержать и запускать цепочку методов с
подходящей сигнатурой.

```
public delegate void MyDelegate(string customString);

public delegate int MyIntDelegate();

public static void DemostrateMulticastDelegateInherirance()
{
    var delegateTypes = new List<Type>
    {
        // наши кастомные типы делегатов
        typeof(MyDelegate),
        typeof(MyIntDelegate),
        // предопределенные типы делегатов
        typeof(Action),
        typeof(Predicate<string>),
        typeof(Func<bool>)
    };

    foreach (var delegateType in delegateTypes)
    {
        var isSubclassOfMulticast = delegateType.IsSubclassOf(typeof(MulticastDelegate));

        Console.WriteLine($"{delegateType.Name} subclass of { nameof(MulticastDelegate)}: { isSubclassOfMulticast }");
    }
}
```

Описание предопределенных делегатов представлено ниже в [разделе](#стандартные-типы-делегатов).

Выполнение приведенного выше кода выведет на консоль следующий
результат, который говорит о том, что все делегаты, как кастомные, так и
предопределенные, являются наследниками класса `MulticastDelegate`:

<img src="lecture_media\media\image2.png" style="width:4.59375in;height:1.32292in" />

Для добавления еще одного метода в цепочку вызовов делегата можно
воспользоваться оператором “+” или “+=”. В этом случае компилятор неявно
преобразует передаваемый метод в делегат, а затем используется метод
[Delegate.Combine](https://docs.microsoft.com/ru-ru/dotnet/api/system.delegate.combine?view=netframework-4.8)
для конкатенации цепочек вызовов двух делегатов.

Аналогично, если необходимо убрать метод из цепочки вызовов, можно
использовать операторы “-” или “-=”, которые “под капотом” преобразуются
в вызов метода
[Delegate.Remove](https://docs.microsoft.com/ru-ru/dotnet/api/system.delegate.remove?view=netframework-4.8).
Удаление методов происходит начиная с конца.

Необходимо помнить о том, что если сигнатура делегата подразумевает
возвращаемое значение, и делегат содержит в себе цепочку методов,
которые необходимо вызвать, то вызывающий код получит возвращаемое
значение <u>только самого последнего метода</u> из цепочки вызова.

```
// первый метод возвращает значение 0
MyIntDelegate myIntDelegate = () => 0;

// второй метод возвращает значение 150
myIntDelegate += () => 150;

// в консоли видим результат: 150
Console.WriteLine(myIntDelegate());
```

# Применение делегатов

Одно из самых распространенных применений делегатов — это механизм
событий (*events*) в .NET, который является темой следующего занятия.

Компонент *LINQ*, рассмотренный на прошлом занятии, практически
полностью построен на использовании делегатов. Например рассмотрим один
из самых используемых *методов-расширений Select*:

<img src="lecture_media\media\image3.png" style="width:6.25in;height:0.95052in" />

Интерес представляет параметр этого метода типа
`Func<TSource,TResult>`, более подробное описание которого следует
ниже. Этот тип является стандартным обобщенным типом делегата в .NET. По
каждому элементу исходной коллекции происходит вызов переданного
*делегата-*селектора*,* который передает этот элемент *методу, скрытому
в этом делегате*. Таким образом формируются элементы выходной коллекции.

# Стандартные типы делегатов

При разработке .NET приложений широко используются стандартные типы
делегатов
[Action](https://docs.microsoft.com/ru-ru/dotnet/api/system.action?view=netframework-4.8)
и
[Func&lt;T&gt;](https://docs.microsoft.com/ru-ru/dotnet/api/system.func-2?view=netframework-4.8).

Тип делегата `Action` является стандартным делегатом *действия без
возвращаемого результата,* следовательно, типом возвращаемого значения
методов, на которые может ссылаться делегат такого типа, является void.
Может принимать до 16 входных параметров. Тип делегата `Action<T>`
можно было бы переписать в следующем представлении:

`public delegate void Action<T>(T value);`

Тип делегата `Func`, напротив, предусматривает обязательное выходное
значение. Может принимать до 16 входных параметров. Тип делегата
`Func<T, TResult>` можно было бы переписать в следующем представлении:

`public delegate TResult Func<T,TResult>(T value);`

Тип, который указывается последним в угловых скобках, является типом
возвращаемого значения для данного делегата.

Зачастую при разработке достаточно стандартных типов делегатов `Action` и
`Func`. Однако существуют сценарии, при которых можно и нужно создавать
собственные типы делегатов:

-   Количество входных параметров более 16;

-   Ключевые слова
    [out](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/out-parameter-modifier),
    [ref](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/ref),
    [params](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/params)
    и значений по умолчанию для входных параметров;

-   Обозначения смысловой нагрузки и переиспользования данного типа
    делегатов.

Также, в .NET предопределен тип делегата `Predicate<T>`, который
применяется в некоторых стандартных методах, например `Array.Find`.
Однако, он редко применяется в промышленной разработке. Ознакомиться с
информацией об этом типе можно на сайте Microsoft:

## Для дополнительного чтения

[Стандартный делегат
System.Predicate](https://docs.microsoft.com/ru-ru/dotnet/api/system.predicate-1?view=netcore-3.1)

[Использование анонимных функций. Лямбда-выражения и анонимные
методы](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions)

[Метод
Delegate.Remove](https://docs.microsoft.com/ru-ru/dotnet/api/system.delegate.remove?view=netframework-4.8)

[Метод
Delegate.Combine](https://docs.microsoft.com/ru-ru/dotnet/api/system.delegate.combine?view=netframework-4.8)

[Методы-расширения](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)

[Использование ключевого слова
params](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/params)

[Использование ключевого слова
ref](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/ref)

[Использование ключевого слова
out](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/out-parameter-modifier)

[Функция обратного вызова 
(Callback)](https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

[Использование вариативности в
делегатах](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates)

# Вопросы

1.  Что такое делегат?

2.  Какие методы могут использоваться в делегатах: статические или
    экземплярные?

3.  Как объявить свой тип делегата?

4.  Какие стандартные типы делегатов существуют?

5.  Как добавить метод в делегат? 3 вида синтаксиса.

6.  Как связаны слова `Delegate`, `MulticastDelegate` и `delegate`?

7.  Какое значение вернет вызов делегата, содержащего несколько методов?

8.  Основные применения делегатов.

| REVISION HISTORY |                       |                 |             |          |                |
|------------------|-----------------------|-----------------|-------------|----------|----------------|
| Ver.             | Description of Change | Author          | Date        | Approved |                |
|                  |                       |                 |             | Name     | Effective Date |
| 0.1              | Initial version       | Dmitry Sorokin1 | 12-MAR-2020 |          | 12-MAR-2020    |
|                  |                       |                 |             |          |                |
|                  |                       |                 |             |          |                |
